#include <stdlib.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h> /* ntohl */

#include "regdb.h"

#define VERIFY_SIGNATURE	1

#ifdef VERIFY_SIGNATURE
#define USE_OPENSSL		1

#ifdef USE_OPENSSL
#include <openssl/bio.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#endif

/* public key */
static __u8 pem_pub_key[] = {
	0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49,
	0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x42, 0x49,
	0x6a, 0x41, 0x4e, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
	0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4d, 0x49, 0x49, 0x42, 0x43,
	0x67, 0x4b, 0x43, 0x41, 0x51, 0x45, 0x41, 0x75, 0x4c, 0x6f, 0x41, 0x65, 0x42, 0x31, 0x44, 0x55,
	0x63, 0x65, 0x4a, 0x5a, 0x64, 0x71, 0x57, 0x5a, 0x35, 0x4f, 0x5a, 0x0a, 0x47, 0x4c, 0x57, 0x66,
	0x75, 0x4d, 0x39, 0x4f, 0x6f, 0x58, 0x79, 0x2b, 0x65, 0x74, 0x64, 0x70, 0x72, 0x30, 0x6d, 0x67,
	0x75, 0x36, 0x38, 0x39, 0x6f, 0x77, 0x72, 0x65, 0x78, 0x69, 0x2b, 0x54, 0x46, 0x37, 0x59, 0x32,
	0x4b, 0x32, 0x55, 0x66, 0x58, 0x79, 0x79, 0x71, 0x38, 0x68, 0x6f, 0x5a, 0x45, 0x6f, 0x49, 0x73,
	0x51, 0x6c, 0x75, 0x6f, 0x6b, 0x45, 0x74, 0x6a, 0x58, 0x4a, 0x47, 0x4d, 0x0a, 0x76, 0x76, 0x2f,
	0x34, 0x47, 0x31, 0x45, 0x6c, 0x36, 0x70, 0x5a, 0x56, 0x34, 0x4e, 0x39, 0x5a, 0x73, 0x42, 0x42,
	0x4b, 0x69, 0x45, 0x2b, 0x61, 0x48, 0x2b, 0x67, 0x43, 0x61, 0x30, 0x69, 0x59, 0x2b, 0x75, 0x66,
	0x49, 0x6f, 0x35, 0x4b, 0x69, 0x49, 0x4f, 0x46, 0x66, 0x74, 0x45, 0x4e, 0x58, 0x6b, 0x41, 0x33,
	0x45, 0x55, 0x50, 0x4f, 0x70, 0x56, 0x69, 0x5a, 0x51, 0x32, 0x4f, 0x62, 0x52, 0x0a, 0x46, 0x51,
	0x41, 0x71, 0x54, 0x38, 0x79, 0x56, 0x4c, 0x51, 0x41, 0x35, 0x79, 0x79, 0x4d, 0x48, 0x4a, 0x34,
	0x62, 0x2f, 0x6b, 0x2b, 0x47, 0x78, 0x5a, 0x67, 0x4c, 0x48, 0x2b, 0x67, 0x61, 0x65, 0x46, 0x32,
	0x55, 0x64, 0x53, 0x38, 0x35, 0x46, 0x41, 0x6f, 0x49, 0x6a, 0x6b, 0x78, 0x52, 0x52, 0x41, 0x54,
	0x4c, 0x34, 0x74, 0x71, 0x42, 0x75, 0x53, 0x32, 0x68, 0x57, 0x31, 0x61, 0x6a, 0x61, 0x0a, 0x6e,
	0x46, 0x45, 0x63, 0x52, 0x42, 0x79, 0x5a, 0x6d, 0x48, 0x54, 0x43, 0x58, 0x4c, 0x2f, 0x57, 0x77,
	0x32, 0x75, 0x4f, 0x54, 0x47, 0x36, 0x52, 0x50, 0x54, 0x6a, 0x6a, 0x4a, 0x2f, 0x2b, 0x47, 0x36,
	0x32, 0x4d, 0x54, 0x50, 0x71, 0x44, 0x77, 0x6d, 0x67, 0x73, 0x4c, 0x79, 0x47, 0x70, 0x43, 0x6f,
	0x63, 0x4f, 0x58, 0x42, 0x43, 0x42, 0x51, 0x48, 0x35, 0x51, 0x5a, 0x42, 0x6e, 0x38, 0x38, 0x0a,
	0x54, 0x47, 0x50, 0x63, 0x33, 0x67, 0x72, 0x65, 0x55, 0x59, 0x52, 0x42, 0x73, 0x64, 0x6a, 0x70,
	0x30, 0x6f, 0x76, 0x71, 0x74, 0x64, 0x65, 0x69, 0x4e, 0x45, 0x2b, 0x6f, 0x30, 0x32, 0x72, 0x64,
	0x46, 0x63, 0x7a, 0x6d, 0x65, 0x6f, 0x56, 0x59, 0x32, 0x6d, 0x52, 0x71, 0x6e, 0x76, 0x62, 0x33,
	0x52, 0x73, 0x4d, 0x54, 0x79, 0x68, 0x66, 0x74, 0x32, 0x32, 0x4e, 0x50, 0x37, 0x69, 0x7a, 0x48,
	0x0a, 0x4c, 0x51, 0x49, 0x44, 0x41, 0x51, 0x41, 0x42, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45,
	0x4e, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d,
	0x2d, 0x2d, 0x0a,
};
#endif

static void *get_file_ptr(__u8 *db, int dblen, int structlen, __be32 ptr)
{
	__u32 p = ntohl(ptr);

	if (p > dblen - structlen) {
		fprintf(stderr, "Invalid database file, bad pointer!\n");
		exit(3);
	}

	return (void *)(db + p);
}

static void print_reg_rule(__u8 *db, int dblen, __be32 ruleptr)
{
	struct regdb_file_reg_rule *rule;
	struct regdb_file_freq_range *freq;
	struct regdb_file_power_rule *power;

	rule = get_file_ptr(db, dblen, sizeof(*rule), ruleptr);
	freq = get_file_ptr(db, dblen, sizeof(*freq), rule->freq_range_ptr);
	power = get_file_ptr(db, dblen, sizeof(*power), rule->power_rule_ptr);

	printf("\t%d..%d kHz (maxbw: %d kHz, mod: 0x%x, restrict: 0x%x)\n",
	       ntohl(freq->start_freq),
	       ntohl(freq->end_freq),
	       ntohl(freq->max_bandwidth),
	       ntohl(freq->modulation_cap),
	       ntohl(freq->misc_restrictions));

	printf("\t -> env: '%.1s', ag: %d, ir_ptmp: %d, ir_ptp: %d, eirp_pmtp: %d, eirp_ptp: %d\n",
	       &power->environment_cap,
	       ntohl(power->max_antenna_gain),
	       ntohl(power->max_ir_ptmp),
	       ntohl(power->max_ir_ptp),
	       ntohl(power->max_eirp_pmtp),
	       ntohl(power->max_eirp_ptp));
}

int main(int argc, char **argv)
{
	int fd;
	struct stat stat;
	__u8 *db;
	struct regdb_file_header *header;
	struct regdb_file_reg_country *countries;
	int dblen, siglen, num_countries, i, j;
#ifdef USE_OPENSSL
	BIO *keybio;
	RSA *rsa;
	__u8 hash[SHA_DIGEST_LENGTH];
#endif

	if (argc != 2) {
		fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
		return 2;
	}

	fd = open(argv[1], O_RDONLY);
	if (fd < 0) {
		perror("failed to open db file");
		return 2;
	}

	if (fstat(fd, &stat)) {
		perror("failed to fstat db file");
		return 2;
	}

	dblen = stat.st_size;

	db = mmap(NULL, dblen, PROT_READ, MAP_PRIVATE, fd, 0);
	if (db == MAP_FAILED) {
		perror("failed to mmap db file");
		return 2;
	}

	header = get_file_ptr(db, dblen, sizeof(*header), 0);

	if (ntohl(header->magic) != REGDB_MAGIC) {
		fprintf(stderr, "Invalid database magic\n");
		return 2;
	}

	if (ntohl(header->version) != REGDB_VERSION) {
		fprintf(stderr, "Invalid database version\n");
		return 2;
	}

	siglen = ntohl(header->signature_length);
	/* adjust dblen so later sanity checks don't run into the signature */
	dblen -= siglen;

	if (dblen <= sizeof(*header)) {
		fprintf(stderr, "Invalid signature length %d\n", siglen);
		return 2;
	}

#ifdef USE_OPENSSL
	/* verify signature */
	keybio = BIO_new_mem_buf(pem_pub_key, sizeof(pem_pub_key));
	if (!keybio) {
		fprintf(stderr, "Failed to create key bio\n");
		return 2;
	}

	rsa = PEM_read_bio_RSA_PUBKEY(keybio, NULL, NULL, NULL);
	if (!rsa) {
		fprintf(stderr, "Failed to create RSA key\n");
		return 2;
	}

	if (RSA_size(rsa) != siglen) {
		fprintf(stderr, "RSA signature length mismatch\n");
		return 2;
	}

	if (SHA1(db, dblen, hash) != hash) {
		fprintf(stderr, "Failed to calculate SHA sum\n");
		return 2;
	}

	if (RSA_verify(NID_sha1, hash, SHA_DIGEST_LENGTH,
		       db + dblen, siglen, rsa) != 1) {
		fprintf(stderr, "Database signature wrong\n");
		return 2;
	}

	RSA_free(rsa);
	BIO_free(keybio);
#endif

	num_countries = ntohl(header->reg_country_num);
	countries = get_file_ptr(db, dblen,
				 sizeof(struct regdb_file_reg_country) * num_countries,
				 header->reg_country_ptr);

	for (i = 0; i < num_countries; i++) {
		struct regdb_file_reg_rules_collection *rcoll;
		struct regdb_file_reg_country *country = countries + i;
		int num_rules;

		printf("Country %.2s\n", country->alpha2);
		rcoll = get_file_ptr(db, dblen, sizeof(*rcoll), country->reg_collection_ptr);
		num_rules = ntohl(rcoll->reg_rule_num);
		/* re-get pointer with sanity checking for num_rules */
		rcoll = get_file_ptr(db, dblen,
				     sizeof(*rcoll) + num_rules * sizeof(__be32),
				     country->reg_collection_ptr);
		for (j = 0; j < num_rules; j++)
			print_reg_rule(db, dblen, rcoll->reg_rule_ptrs[j]);
	}

	return 0;
}
